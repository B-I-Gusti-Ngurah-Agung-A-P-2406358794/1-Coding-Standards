## Advanced Programming Task
Name: I Gusti Ngurah Agung Airlangga Putra

Class / NPM: B / 2406358794

## Module 2
#### ( Module 1 Read me is below module 2 )
### Q1: Code quality issue(s) fixed and strategy

Selama exercise ini, saya memperbaiki beberapa code quality issues yang terdeteksi oleh SonarCloud. Pertama, saya menghilangkan duplikasi literal "redirect:/product/list" di ProductController dengan membuat sebuah konstanta (private static final String REDIRECT_PRODUCT_LIST) dan mengganti seluruh penggunaan literal tersebut dengan konstanta agar kode lebih maintainable dan mengurangi risiko typo. Kedua, saya menghapus commented-out code di ProductRepositoryTest karena kode yang tidak digunakan dapat menurunkan keterbacaan dan membingungkan developer lain. Ketiga, saya menambahkan penjelasan singkat pada method contextLoads() di EshopApplicationTests untuk menjelaskan bahwa method tersebut memang sengaja kosong dan digunakan untuk memastikan Spring context berhasil dijalankan. Strategi saya adalah memperbaiki issue yang berdampak pada maintainability terlebih dahulu, memastikan perubahan tidak mengubah perilaku aplikasi, lalu memverifikasi kembali melalui pipeline CI/CD dan hasil analisis SonarCloud.

### Q2: Evaluation of CI/CD implementation

Menurut saya, implementasi yang saya buat sudah memenuhi konsep Continuous Integration (CI) karena setiap ada push atau pull request, GitHub Actions secara otomatis menjalankan proses build dan test sehingga perubahan kode langsung tervalidasi tanpa perlu eksekusi manual. Selain itu, integrasi dengan SonarCloud memungkinkan analisis kualitas kode dilakukan secara otomatis pada setiap perubahan, sehingga potensi code smells atau maintainability issues dapat terdeteksi lebih awal. Untuk Continuous Deployment (CD), aplikasi secara otomatis ter-deploy ke PaaS (Render) setiap ada perubahan pada branch utama (main), sehingga versi terbaru aplikasi langsung tersedia secara online tanpa proses deploy manual. Dengan adanya otomatisasi build, test, code analysis, dan deployment, workflow ini sudah mencerminkan praktik dasar CI/CD yang terintegrasi dan berkelanjutan.
## Module 1
### Reflection 1
In this project, I implemented the edit and delete product features using Spring Boot and followed several clean code principles that I learned in this module. I tried to keep the code simple and easy to read by separating the controller, service, and repository layers so each class has a clear responsibility. I also used meaningful method names like update, and delete so the purpose of each function is easy to understand. In addition, I avoided repeating logic by placing business processes inside the service layer instead of directly in the controller. For secure coding, I used POST requests for actions that change data such as edit and delete, and I avoided exposing internal data unnecessarily. I also added basic checks, such as redirecting to the product list page when a product is not found, to prevent errors.

However, after reviewing the code again, I noticed some parts that can still be improved. The repository currently stores data in a simple list without validation or persistence, which is not safe for real applications. The code also does not include proper error handling or input validation, so invalid data could still be submitted. In the future, this could be improved by adding validation, better exception handling, and using a real database instead of in-memory storage. Overall, this exercise helped me understand how clean structure, clear naming, and safe request handling can make code easier to maintain and more secure.

### Reflection 2

1 - After writing the unit tests, I felt more confident because the features can be checked automatically without always running the whole application. In one class, unit tests should stay focused on one component and cover the main behaviors such as normal cases, edge cases, and possible failure cases. There is no exact number of tests, but they should be enough to verify the important logic of the feature. To make sure the tests are sufficient, I can use code coverage to see which parts of the code are not tested yet and then add tests for those paths. However, even if code coverage reaches 100%, it does not guarantee the program has no bugs, because tests might miss real-world scenarios, integration problems, or incorrect assumptions in the assertions.

2- Creating another functional test suite with the same setup and variables can make the code less clean because many parts of the code will be duplicated. This repetition reduces maintainability and increases the risk of inconsistencies when changes are needed. The potential clean code issue here is duplicated setup logic and repeated Selenium interaction steps across multiple test classes. To improve this, common setup and helper actions should be extracted into a shared base class or utility methods so each functional test stays short and focused on its specific purpose. Using consistent selectors and reusable helper functions will keep the tests clearer, easier to maintain, and will prevent the new functional test from lowering overall code quality.